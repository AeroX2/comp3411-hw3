#!/usr/bin/python3
# ^^ note the python directive on the first line
# COMP 9414 agent initiation file 
# requires the host is running before the agent
# designed for python 3.6
# typical initiation would be (file in working directory, port = 31415)
#        python3 agent.py -p 31415
# created by Leo Hoare
# with slight modifications by Alan Blair

import sys
import copy
import socket
from enum import Enum, auto

from agent_idea import Coord,Grid,Player,State,Direction

def rotate_right(view):
    return [list(reversed(x)) for x in zip(*view)]

def rotate_left(view):
    return list(zip(*[reversed(x) for x in view]))

# Declaring visible grid to agent
view = [['' for _ in range(5)] for _ in range(5)]

grid = None
state = State.EXPLORE
player = Player()

#Find an item in the grid
def find_item(grid, item):
    for y,line in enumerate(grid):
        for x,v in enumerate(line):
            if (v != item):
                continue

            path_list = path_find((x,y))
            if (path_list is not None):
                return (x,y)
    return None

#Use BFS to find the shortest path
def path_find_full(target,accepted,debug=False):
    visited = set()

    start = (player.x, player.y, 0)
    queue = [[start]]

    while queue:
        path = queue.pop(0)
        curr_pos_x,curr_pos_y,error = path[-1]

        for direction in [(0,1),(0,-1),(-1,0),(1,0)]:
            new_pos = (curr_pos_x+direction[0],curr_pos_y+direction[1])

            #Check if we have reached the target
            if (new_pos == target):
                return path

            #Check if we can move in this direction
            cell = grid.safe_get(new_pos)
            if (cell is None):
                continue;

            new_state = (new_pos[0],new_pos[1],error) #(new_pos,player_state)
            if (new_state in visited):
                continue
            visited.add(new_state)

            if (cell in accepted and error <= 0):
                new_path = path[:]+[new_state]
                queue.append(new_path)
            elif (error < 1):
                new_state = (new_pos[0],new_pos[1],error+1) #(new_pos,player_state)
                new_path = path[:]+[new_state]
                queue.append(new_path)
    return None

#Convert a path to a command list
def path_to_commands(path, player, target):
    translation = {
        (0,-1): Direction.NORTH,
        (0,1): Direction.SOUTH,
        (-1,0): Direction.WEST,
        (1,0): Direction.EAST
    }

    current_direction = player.direction
    commands = ''

    raw_direction = (target[0]-player.x, target[1]-player.y)
    if (raw_direction in translation):
        direction = translation[raw_direction]
        commands += Direction.difference(current_direction, direction)

    for i,pos in enumerate(path[:-1],1):
        raw_direction = (path[i][0]-path[i-1][0],path[i][1]-path[i-1][1])
        direction = translation[raw_direction]

        commands += Direction.difference(current_direction, direction)
        commands += 'F'
        current_direction = direction

    return commands

def explore():
    print("Exploring")

    #Find all the unknowns and sort them by distance from the player
    unknowns = [(x,y) for y,line in enumerate(grid) for x,v in enumerate(line) if v == 'X']
    unknowns = sorted(unknowns, key=lambda x: abs(x[0]-player.x)+abs(x[1]-player.y))
    if (player.target is not None and grid.safe_get(player.target) == 'X'):
        unknowns.insert(0,player.target)

    #Check if we can reach one of the unknowns
    accepted = [' ','a','k','o','O','X']
    for coord in unknowns:
        path_list = path_find_full(coord,accepted)
        if (path_list is None):
            continue

        player.target = coord;
        return path_to_commands(path_list,player,coord)+'F',State.EXPLORE

    #accepted = [' ','a','k','o','O','X','~']
    #for coord in unknowns:
    #    path_list = path_find_full(coord,accepted)
    #    if (path_list is None):
    #        continue

    #    player.target = coord;
    #    return path_to_commands(path_list,player,coord)+'F',State.EXPLORE

    #If we can't reach any of the unknowns without crossing water, then we need a axe and a raft
    #if (not player.has_axe):
    #    commands,state = axe();
    #elif (not player.has_raft):
    #    commands,state = raft();
    #return commands,state

def can_win():
    print("Checking if we can win")

    treasure = find_item(grid,'$')
    if (treasure is None and not player.has_treasure):
        return None,None

    accepted = [' ','a','k','o','O']
    if (player.has_raft):
        accepted.append('~')
    if (player.has_key):
        accepted.append('-')
    key_path_list = path_find_full(treasure,accepted)
    if (key_path_list is None):
        return None,None

    coord = (player.ix, player.iy)
    home_path_list = path_find_full(coord,accepted)
    if (home_path_list is None):
        return None,None

    return path_to_commands(key_path_list,player,coord)+'F'+ \
           path_to_commands(home_path_list,player,coord)+'F',State.EXPLORE

#Function to take get action from AI or user
def get_actions(view):
    global grid
    global player
    global state

    if (grid is None):
        grid = Grid(view)
    else:
        #Check if the grid needs to be expanded
        grid.expand_map(player)

        #Rotate the view grid
        if (player.direction == Direction.EAST): 
            view = rotate_right(view)
        elif (player.direction == Direction.WEST): 
            view = rotate_left(view)
        elif (player.direction == Direction.SOUTH): 
            view = rotate_right(view)
            view = rotate_right(view)

        #Update the grid
        for i in range(-2, 3):
            for ii in range(-2, 3):
                grid.set((player.y+i,player.x+ii),view[i+2][ii+2])

    #print(len(grid[0]), len(grid))
    print("GRID")
    print(player.x, player.y, player.direction.name)
    #print_map(grid)
    grid.print()

    commands = None
    #commands,state = can_win()
    if (commands is None):
        commands = explore()
        commands = commands[0:1]

    command = commands[0]
    if (command == 'F'):
        player.forward(grid)
    elif (command == 'L'):
        player.left()
    elif (command == 'R'):
        player.right()
    elif (command == 'C'):
        player.cut()

    return commands

#Helper function to print the grid
def print_map(map):
    print('+'+'-'*len(map[0])+'+')
    for line in map:
        print('|'+''.join(line)+'|')
    print('+'+'-'*len(map[0])+'+')

if __name__ == "__main__":
    # checks for correct amount of arguments 
    if len(sys.argv) != 3:
        print("Usage Python3 "+sys.argv[0]+" -p port \n")
        sys.exit(1)

    port = int(sys.argv[2])

    # checking for valid port number
    if not 1025 <= port <= 65535:
        print('Incorrect port number')
        sys.exit()

    # creates TCP socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
         # tries to connect to host
         # requires host is running before agent
         sock.connect(('localhost',port))
    except (ConnectionRefusedError):
         print('Connection refused, check host is running')
         sys.exit()

    import time

    # navigates through grid with input stream of data
    i=0
    j=0
    while True:
        data = sock.recv(100)
        if not data:
            sys.exit()

        for ch in data:
            if (i == 2 and j == 2):
                view[i][j] = '^'
                view[i][j+1] = chr(ch)
                j+=1 
            else:
                view[i][j] = chr(ch)
            j+=1
            if (j > 4):
                j=0
                i=(i+1)%5

        if (j == 0 and i == 0):
            actions = get_actions(view)
            actions_encoded = ''.join(actions).encode('utf-8')

            sock.send(actions_encoded)
            #time.sleep(1)

